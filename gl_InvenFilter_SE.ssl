
#define SFALL_SC_EVALUATION   (true)

#define COMBINE_VERSION       (1)
#define SCRIPT_VERSION        " [Advanced v.1.3.6]"

#define iniConfigFile         "sfall_ini/InvenFilter.ini|InventoryFilter|"


#include "..\m_headers\define.h"
#include "..\m_headers\command.h"
#include "..\m_headers\party.h"

#include "..\m_headers\sfall\sfall.h"
#include "..\m_headers\sfall\define_extra.h"
#include "..\m_headers\sfall\dik.h"

procedure start;
procedure CreateInvenFilterMenu(variable loot);
procedure CreateInvenFilterMenu_trader(variable loot);

procedure filter_inventory(variable filter_item_type, variable spec);
procedure filter_inventory_trader(variable filter_item_type);
procedure filter_inventory_sub(variable filter_item_type, variable spec_item, variable obj_ptr_1, variable obj_ptr_2);
procedure filter_remove_items(variable source_objptr, variable dest_objptr, variable item, variable item_pid);
procedure check_tile_object;
procedure Check_Party_Obj;
procedure Move_Dude_Inv;
procedure check_bags_items(variable who_ptr);
procedure restore_bags_items(variable who_ptr);
procedure hMoveItem;
procedure hBarter;
procedure hKeyPress;
procedure hMouseClick;

procedure inven_filter_button_toggle(variable p_btn, variable spec);
procedure inven_filter_button_pressed(variable p_btn, variable filter_item_type, variable spec);
procedure inven_filter_trd_button_toggle(variable p_btn);
procedure inven_filter_trd_button_pressed(variable p_btn, variable filter_item_type);
procedure Button_Toggle_Off;

procedure SelectCreateButton(variable p_btn, variable flag);
procedure create_btn_sub;
procedure create_btn_trd_sub;
procedure Create_btn_all(variable flag, variable trd);
procedure Create_btn_armor(variable flag, variable trd);
procedure Create_btn_weapon(variable flag, variable trd);
procedure Create_btn_ammo(variable flag, variable trd);
procedure Create_btn_drug(variable flag, variable trd);
procedure Create_btn_misc(variable flag, variable trd);
procedure subCreateButton(variable btn, variable flag, variable trd, variable vshift);
procedure DeletePressButton;
procedure DeletePressButtonTrd;
procedure subDeleteButton(variable btn, variable type, variable flag);
procedure weight_win(variable weight, variable type);
procedure weight_loot_win(variable weight, variable obj);
procedure barter_weight_win(variable weight);
procedure trader_cost_win;
procedure None;
procedure Dude_Loot_Object;
procedure hUseSkills;
procedure hack_engine_weight(variable hack);

#define x_loc       (10)
#define y_loc       (6)
#define horiz_size  (46)  // button size
#define vertic_size (23)


#define item_type_misc_group     (8)

#define armor_engine_weight(x)   (x == PID_POWERED_ARMOR) or (x == PID_HARDENED_POWER_ARMOR) or (x == PID_ADVANCED_POWER_ARMOR) or (x == PID_ADVANCED_POWER_ARMOR_MK2)

#define MiscGroupOlymps(x)       (x == 247) or (x == 393)

#define MiscGroupNevada(x)       (x == 556) or (x == 557) or (x == 647)

#define MiscGroup(x)   MiscGroupNevada(x) or MiscGroupOlymps(x) or \
                      (x == PID_STEALTH_BOY) or (x == PID_GEIGER_COUNTER) or (x == PID_MOTION_SENSOR) or (x == PID_ACTIVE_GEIGER_COUNTER) or (x == PID_ACTIVE_STEALTH_BOY) or \
                      (x == PID_ELECTRONIC_LOCKPICKS) or (x == PID_LOCKPICKS) or (x == PID_EXP_LOCKPICK_SET) or (x == PID_ELEC_LOCKPICK_MKII) or (x == PID_MULTI_TOOL) or (x == PID_SUPER_TOOL_KIT) or \
                      (x == PID_BIG_BOOK_OF_SCIENCE) or (x == PID_DEANS_ELECTRONICS) or (x == PID_FIRST_AID_BOOK) or (x == PID_SCOUT_HANDBOOK) or (x == PID_GUNS_AND_BULLETS)


#define Explosive(x)   (x == PID_DYNAMITE) or (x == PID_PLASTIC_EXPLOSIVES) or (x == PID_ACTIVE_DYNAMITE) or (x == PID_ACTIVE_PLASTIC_EXPLOSIVE)

#define ExcludeMisc(x) (x != PID_FIRST_AID_KIT) and (x != PID_DOCTORS_BAG) and (x != PID_PARAMEDICS_BAG) and (x != PID_FIELD_MEDIC_KIT)
#define IncludeMisc(x) (x == PID_FIRST_AID_KIT) or (x == PID_DOCTORS_BAG) or (x == PID_PARAMEDICS_BAG) or (x == PID_FIELD_MEDIC_KIT)

#define inven_filter_button_all     ((get_mouse_x > menu_x + x_loc and get_mouse_x < menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc and get_mouse_y < menu_y + y_loc + 21))
#define inven_filter_button_armor   ((get_mouse_x > menu_x + x_loc and get_mouse_x < menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc + vertic_size and get_mouse_y < menu_y + y_loc + 21 + vertic_size))
#define inven_filter_button_weapon  ((get_mouse_x > menu_x + x_loc and get_mouse_x < menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc + (vertic_size*2) and get_mouse_y < menu_y + y_loc + 21 + (vertic_size*2)))
#define inven_filter_button_ammo    ((get_mouse_x > menu_x + x_loc and get_mouse_x < menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc + (vertic_size*3) and get_mouse_y < menu_y + y_loc + 21 + (vertic_size*3)))
#define inven_filter_button_drug    ((get_mouse_x > menu_x + x_loc and get_mouse_x < menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc + (vertic_size*4) and get_mouse_y < menu_y + y_loc + 21 + (vertic_size*4)))
#define inven_filter_button_misc    ((get_mouse_x > menu_x + x_loc and get_mouse_x < menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc + (vertic_size*5) and get_mouse_y < menu_y + y_loc + 21 + (vertic_size*5)))

#define inven_filter_trd_button_all     ((get_mouse_x > t_menu_x + x_loc and get_mouse_x < t_menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc and get_mouse_y < menu_y + y_loc + 21))
#define inven_filter_trd_button_armor   ((get_mouse_x > t_menu_x + x_loc and get_mouse_x < t_menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc + vertic_size and get_mouse_y < menu_y + y_loc + 21 + vertic_size))
#define inven_filter_trd_button_weapon  ((get_mouse_x > t_menu_x + x_loc and get_mouse_x < t_menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc + (vertic_size*2) and get_mouse_y < menu_y + y_loc + 21 + (vertic_size*2)))
#define inven_filter_trd_button_ammo    ((get_mouse_x > t_menu_x + x_loc and get_mouse_x < t_menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc + (vertic_size*3) and get_mouse_y < menu_y + y_loc + 21 + (vertic_size*3)))
#define inven_filter_trd_button_drug    ((get_mouse_x > t_menu_x + x_loc and get_mouse_x < t_menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc + (vertic_size*4) and get_mouse_y < menu_y + y_loc + 21 + (vertic_size*4)))
#define inven_filter_trd_button_misc    ((get_mouse_x > t_menu_x + x_loc and get_mouse_x < t_menu_x + x_loc + horiz_size) and (get_mouse_y > menu_y + y_loc + (vertic_size*5) and get_mouse_y < menu_y + y_loc + 21 + (vertic_size*5)))

                                        //840                                       850                                           593                                         605
#define button_exit_barter          ((get_mouse_x > (screen_width_half) + 263 and get_mouse_x < (screen_width_half) + 278) and (get_mouse_y > (screen_height_half) + 160 + shift_y and get_mouse_y < (screen_height_half) + 175 + shift_y))
#define button_exit_barter_check    ((x_mouse > (screen_width_half) + 263 and x_mouse < (screen_width_half) + 278) and (y_mouse > (screen_height_half) + 160 + shift_y and y_mouse < (screen_height_half) + 175 + shift_y))

//x790 y530  1152x864/2=576x432   790-576=214    530-432=98
#define button_exit_loot            ((get_mouse_x > (screen_width_half) + 207 and get_mouse_x < (screen_width_half) + 223) and (get_mouse_y > (screen_height_half) + 92 and get_mouse_y < (screen_height_half) + 109))
#define button_exit_loot_check      ((x_mouse > (screen_width_half) + 207 and x_mouse < (screen_width_half) + 223) and (y_mouse > (screen_height_half) + 92 and y_mouse < (screen_height_half) + 109))

variable begin
   screen_width_half, screen_height_half;
   x_mouse, y_mouse;

   no_check_bags;
   sfall_crafty;
   enable_filter;
   enable_weight := false;
   enable_caps := false;
   _hack_weight;

   btn_toggle_off;
   btn_trd_toggle_off;

   menu_x;
   menu_y, shift_y;
   btn_all, btn_armor, btn_weapon, btn_ammo, btn_drug, btn_misc;
   inventory_once;
   pressed_once;
   special;
   critter;
   sec_click;

   //for trader
   t_menu_x;
   btn_trd_all, btn_trd_armor, btn_trd_weapon, btn_trd_ammo, btn_trd_drug, btn_trd_misc;
   critter_tbox, trader_ptr;
   dude_in_barter, dude_enter_barter;

   //for loot
   object_array;
   loot_filter, loot_once;
   contr_use, contr_ptr;

   inven_weight;
   inven_loot_weight;
   inven_caps;
   filter_done := true;
   loot_weight;
   pc_bTable;
   smart_barter;

   container_array;
   container_count_array;
   trd_container_array;
   trd_container_count_array;

   //COMBINE_VERSION
   CNTR_USE, used, usedSkill;

   skill_object;
end

procedure start begin
   variable unsafe, counter, item, pid;

   if game_loaded then begin
                                                                                // for sFall 4.0+
      sfall_crafty := (sfall_ver_build == "sfall2" or sfall_ver_build == 509 or sfall_ver_major > 3);
      enable_filter := not(get_sfall_global_int("INV_FLTR"));

      if not(sfall_crafty) then begin
         counter := (100 * sfall_ver_major) + (10 * sfall_ver_minor) + sfall_ver_build;
         if counter < 382 then begin
            display_msg("InventoryFilter advanced version requires sfall version 3.8.2(or higher), or a version by Crafty.");
            return;
         end
         no_check_bags := (counter >= 383); // исправлена ошибка удаления контейнеров

         unsafe := get_ini_setting("ddraw.ini|Debugging|AllowUnsafeScripting");
         unsafe := unsafe and get_ini_setting("ddraw.ini|Debugging|Enable");
         if unsafe <= 0 and enable_filter then begin
            display_msg(get_ini_string(iniConfigFile + "MsgLoad"));
            return;
         end
      end

      // иcправление функции add_mult_objs_to_inven - если количество превышает 99999
      write_int(0x45A2A0, 0x1869F);

      if not(enable_filter) then display_msg(get_ini_string(iniConfigFile + "MsgInfo"));
      enable_weight := get_ini_setting(iniConfigFile + "ShowWeight");
      enable_caps := get_ini_setting(iniConfigFile + "ShowCaps");
      smart_barter := get_ini_setting(iniConfigFile + "SmartBarter");

      register_hook_proc(HOOK_KEYPRESS, hKeyPress);
      register_hook_proc(HOOK_MOUSECLICK, hMouseClick);
      register_hook_proc(HOOK_BARTERPRICE, hBarter);
      register_hook_proc(HOOK_REMOVEINVENOBJ, hMoveItem);
      register_hook_proc(HOOK_USESKILL, hUseSkills);

      set_global_script_type(1);
      set_global_script_repeat(1 + (sfall_crafty * 10));

      screen_width_half := get_screen_width / 2;
      screen_height_half := get_screen_height / 2;
      if get_screen_height == 480 then shift_y := 50;
      //hd_mode := (get_screen_width > 480);

     #if DEBUG
        // test items
        counter := 50;
        item_caps_adjust(dude_obj, 1000);
        while counter > 0 do begin
           pid := random(1, 618);
           if get_proto_data(pid, PROTO_IT_TYPE) != item_type_container then begin
              item := create_object(pid, 0, 0);
              add_mult_objs_to_inven(dude_obj, item, 1);
              counter -= 1;
           end
        end
     #endif
   end
   else if enable_filter then begin

       ////////// Check object region ////////////////

       if (get_game_mode BWAND INTFACELOOT) then begin
           if not(loot_once) then begin
               loot_once := true;
               call check_tile_object;
           end
       end
       else if loot_once then begin
                    loot_once := false;
                    loot_filter := false;
                end
       #if COMBINE_VERSION
                else if not(sfall_crafty or loot_filter) and (get_game_mode == 0) then
                        call Dude_Loot_Object; // only for standart sfall

       ////////////////////////////////////////////////

       if not(sfall_crafty) and (dude_in_barter or loot_filter) and key_pressed(DIK_ESCAPE) then begin
          dude_in_barter := false;
          loot_filter := false;
       end
       #endif

       if loot_weight and loot_filter then begin
            if obj_type(contr_ptr) == OBJ_TYPE_CRITTER then begin
               call weight_loot_win(who_carry_amount(contr_ptr), contr_ptr);
            end //else call weight_loot_win("---");    //call_offset_r1(0x479A20, contr_ptr)
            call weight_win(who_carry_amount(dude_obj), 0);
            loot_weight := false;
       end

       if (get_game_mode BWAND (INTFACEUSE BWOR INVENTORY BWOR BARTER) or loot_filter
          or (not(sfall_crafty) and (get_game_mode BWAND DIALOG) and dude_in_barter)) then begin
          //inventory on
          if not(inventory_once) then begin
             inventory_once:=true;
             call CreateInvenFilterMenu(loot_filter);
             if dude_in_barter or loot_filter then begin
                call CreateInvenFilterMenu_trader(loot_filter);
                critter_tbox := create_object(PID_MELEE_THUG_MALE, 0, 2);
             end
          end
          if loot_filter then call Button_Toggle_Off;
       end
       else if inventory_once then begin
          //inventory off
          inventory_once := false;
          deleteWin("inven_filter");
          if critter then begin
             move_obj_inven_to_obj(critter, dude_obj);
             destroy_object(critter);
          end
          if not(loot_filter) then call restore_bags_items(dude_obj);  // for player
          if dude_enter_barter or contr_use then begin
             if contr_use then begin
                 contr_use := false;
                 //call restore_bags_items(contr_ptr);  // for loot
                 move_obj_inven_to_obj(critter_tbox, contr_ptr);
                 if trader_ptr then destroy_object(trader_ptr);
             end else begin
                 move_obj_inven_to_obj(critter_tbox, trader_ptr);
                 call restore_bags_items(trader_ptr);  // for trader
                 if inven_caps then deleteWin("inven_caps");
                 inven_caps := false;
             end
             destroy_object(critter_tbox);
             deleteWin("inven_filter_trd");
             btn_trd_all := true;
             dude_enter_barter := false;
             dude_in_barter := false;
          end
          if inven_weight then deleteWin("inven_weight");
          if inven_loot_weight then deleteWin("inven_loot_weight");
          inven_loot_weight := false;
          inven_weight := false;
          critter := 0;
          trader_ptr := 0;
          if (_hack_weight) then call hack_engine_weight(false);
       end
       skill_object := 0; // обнуляем
   end
end

procedure CreateInvenFilterMenu(variable loot) begin

   // параметры окна
   if (get_game_mode BWAND DIALOG) then begin
     menu_x := (screen_width_half) - 320;                  //- 384   //- 320 for olymp
     menu_y := (screen_height_half) - 150 + shift_y;       //+ 40   //- 150  for olymp
   end
   else if loot then begin // for Loot inventar
     menu_x := (screen_width_half) - 331;
     if menu_x < 0 then menu_x := 0;
     menu_y := (screen_height_half) - 238;
     loot_weight := enable_weight; // включает отображение окна с весом для LOOT
   end
   else if (get_game_mode BWAND INTFACEUSE) then begin  // for USE inventar
     menu_x := (screen_width_half) - 208;
     menu_y := (screen_height_half) - 238;
   end
   else begin // for PC inventar
     menu_x := (screen_width_half) - 312;
     menu_y := (screen_height_half) - 238;
   end

   if menu_x < 0 then menu_x := 0;
   if menu_y < 0 then menu_y := 0;

   //создание окна
   createWin("inven_filter", menu_x, menu_y, 63, 150);
   selectWin("inven_filter");
   display("PCX\\inv_filter\\main_form.pcx");

   if not(loot) then call Create_btn_all("on", 0);
   call Create_btn_armor("off", 0);
   call Create_btn_weapon("off", 0);
   call Create_btn_ammo("off", 0);
   call Create_btn_drug("off", 0);
   call Create_btn_misc("off", 0);

   showWin;

   if enable_weight and (get_game_mode BWAND DIALOG) then call barter_weight_win(0);

   if loot then btn_all := false; else btn_all := true;
   btn_armor := false;
   btn_weapon := false;
   btn_ammo := false;
   btn_drug := false;
   btn_misc := false;
   special := false;

end

procedure CreateInvenFilterMenu_trader(variable loot) begin

   // параметры окна
   if loot then
      t_menu_x := (screen_width_half) + 269; // for Loot
   else
      t_menu_x := (screen_width_half) + 255; // for Barter

   //создание окна
   createWin("inven_filter_trd", t_menu_x, menu_y, 63, 150);
   selectWin("inven_filter_trd");
   display("PCX\\inv_filter\\main_form.pcx");

   if not(loot) then call Create_btn_all("on", 1);
   call Create_btn_armor("off", 1);
   call Create_btn_weapon("off", 1);
   call Create_btn_ammo("off", 1);
   call Create_btn_drug("off", 1);
   call Create_btn_misc("off", 1);

   showWin;

   //if (not(loot) and enable_caps) then
      call trader_cost_win when (loot == false and enable_caps);

   if loot then btn_trd_all := false; else btn_trd_all := true;
   btn_trd_armor := false;
   btn_trd_weapon := false;
   btn_trd_ammo := false;
   btn_trd_drug := false;
   btn_trd_misc := false;

end

procedure filter_inventory(variable filter_item_type, variable spec) begin
variable begin
   item, spec_item;
   crttr, intfc := 3;
   weight;
end

   if filter_item_type != (-1) then
      call check_bags_items(dude_obj);
   else
      call restore_bags_items(dude_obj);  //restore bags item for all

   spec_item := 7;
   if spec then
      if filter_item_type == item_type_ammo then
         spec_item := item_type_weapon;
   else
      spec_item := item_type_ammo;

   if critter == 0 then
      critter := create_object(PID_MELEE_THUG_MALE, 0, 2);
   else
      move_obj_inven_to_obj(critter, dude_obj);

   if filter_item_type != (-1) then weight := filter_inventory_sub(filter_item_type, spec_item, dude_obj, critter);
   //if filter_item_type==(-1) then call restore_bags_items(dude_obj);  //restore bags item for all

   //показывать деньги сверху в режиме бартера при выборе категории ALL/MISC
   if (filter_item_type == (-1) or filter_item_type == item_type_misc_item) and not(get_game_mode BWAND INTFACELOOT) then begin
      item := obj_carrying_pid_obj(dude_obj, PID_BOTTLE_CAPS);
      if item != 0 then begin
         call filter_remove_items(dude_obj, dude_obj, item, PID_BOTTLE_CAPS);
      end
   end

   if (filter_item_type == item_type_misc_item and not(get_game_mode bwand INTFACELOOT)) then weight += restore_bags_items(dude_obj);  // restore bags item for misc item

   if dude_in_barter or loot_filter then begin
        if loot_filter then begin // принцип сортировки для LOOT интерфейса
           // перемещаем инвентарь dude в инвентарь временного криттера (решение бага с надетой броней, когда применяется функция move_obj_inven_to_obj характеристики брони уходят в минуса)
           crttr := Move_Dude_Inv;                                   // TODO - Требуется протестировать этот баг на напарниках, возможно он также имеется.
           move_obj_inven_to_obj(critter, dude_obj);
           call restore_bags_items(dude_obj);  //restore bags item
           move_obj_inven_to_obj(crttr, dude_obj);
           destroy_object(crttr);
           intfc := 2;
           filter_done := true;
        end
        write_int(0x59E844 + (read_int(0x59E96C) * 4), 0);
        call_offset_v3(0x46FDF4, 0, -1, intfc); /* display_inventory_*/
   end
   else begin
      if (get_game_mode == INVENTORY) then begin
         if not(enable_weight) then begin
            if not(_hack_weight) and filter_item_type != (-1) then
               call hack_engine_weight(true);
            else if (filter_item_type == (-1)) then
               call hack_engine_weight(false);
         end else
            call weight_win(weight, filter_item_type);

         if sfall_ver_major >= 4 and sfall_ver_build >= 2 then
            display_stats;
         else
            call_offset_v0(0x471D5C);  /* display_stats_*/
      end
      tap_key(DIK_HOME);
   end

end

procedure filter_inventory_trader(variable filter_item_type) begin

variable item, intfc := 3;

   // перемещаем инвентарь контейнера в инвентарь криттера
   if loot_filter then begin
      if trader_ptr == 0 then trader_ptr := create_object(PID_MELEE_THUG_MALE, 0, 2);
      move_obj_inven_to_obj(contr_ptr, trader_ptr);
   end

   if filter_item_type != (-1) then
      call check_bags_items(trader_ptr);
   else
      call restore_bags_items(trader_ptr);  //restore bags item for trader - for select ALL

   if (critter_tbox == 0) then
      critter_tbox := create_object(PID_MELEE_THUG_MALE, 0, 2);
   else
      move_obj_inven_to_obj(critter_tbox, trader_ptr);

   if (filter_item_type != (-1)) then
      call filter_inventory_sub(filter_item_type, -1, trader_ptr, critter_tbox);

   //показывать деньги сверху в режиме бартера
   if (get_game_mode BWAND DIALOG) and (filter_item_type == item_type_misc_item or filter_item_type == (-1)) then begin
      item:=obj_carrying_pid_obj(trader_ptr, PID_BOTTLE_CAPS);
      if (item != 0) then call filter_remove_items(trader_ptr, trader_ptr, item, PID_BOTTLE_CAPS);
      if (filter_item_type == item_type_misc_item) then call restore_bags_items(trader_ptr);  // restore bags item for misc item
   end

   // принцип сортировки для LOOT интерфейса
   if loot_filter then begin
       //возвращаем инвентарь в контейнер
       call restore_bags_items(contr_ptr);  //restore bags item loot
       move_obj_inven_to_obj(critter_tbox, contr_ptr);
       move_obj_inven_to_obj(trader_ptr, contr_ptr);
       intfc := 2;
       filter_done := true;
   end

   write_int(0x59E7EC + (read_int(0x59E948) * 4), 0);
   call_offset_v4(0x47036C, 0, -1, read_int(0x59E978), intfc); /* display_target_inventory_ */
   call_offset_v1(0x4D6F5C, read_int(0x59E964));               /* win_draw_*/

end

procedure filter_inventory_sub(variable filter_item_type, variable spec_item, variable source_objptr, variable dest_objptr) begin

variable item_pid, item, items, item_counter := 0;
variable weight, prev_counter := 0;

   while inven_ptr(source_objptr, item_counter) > 0 and item_counter < 1000 do begin
      item := inven_ptr(source_objptr, item_counter);
      item_pid := obj_pid(item);

      //в режиме торговли если предмет деньги то остаются в инвентаре игрока.
      if (item_pid != PID_BOTTLE_CAPS or (get_game_mode BWAND (INVENTORY BWOR INTFACEUSE)) or loot_filter) then begin
         if filter_item_type < item_type_misc_item then begin
            if filter_item_type == item_type_drug then begin
               //debug_msg("drug item:"+obj_pid(item));
               //не исключаются drugs и некоторые предметы относящиеся к этому типу
               if obj_item_subtype(item) != item_type_drug and ExcludeMisc(item_pid) then begin
                  call filter_remove_items(source_objptr, dest_objptr, item, item_pid);
               end else item_counter++;
            end
            else begin
               //не исключаются предметы тип которых соответствует фильтру
               if obj_item_subtype(item) != filter_item_type and obj_item_subtype(item) != spec_item then begin
                  // для фильтра оружие не удаляем динамиты
                  if filter_item_type == item_type_weapon and (Explosive(item_pid)) then
                     item_counter++;
                  else begin
                     call filter_remove_items(source_objptr, dest_objptr, item, item_pid);
                  end
               end else item_counter++;
            end
         end
         else begin
            if filter_item_type == item_type_misc_group then begin
               //неисключаются полезные вещи из категории misc
               if (MiscGroup(item_pid)) and obj_item_subtype(item) >= item_type_misc_item then
                  item_counter++;
               else begin
                  call filter_remove_items(source_objptr, dest_objptr, item, item_pid);
               end
            end else //не исключаются misc и key
            if obj_item_subtype(item) != item_type_misc_item and obj_item_subtype(item) != item_type_key_item
            or (IncludeMisc(item_pid) or Explosive(item_pid)) then begin
               call filter_remove_items(source_objptr, dest_objptr, item, item_pid);
            end else item_counter++;
         end

         if enable_weight and (item_counter > prev_counter) then begin //если больше то считаем вес этого предмета
            items := obj_is_carrying_obj(dude_obj, item);
            if enable_weight and obj_item_subtype(item) == item_type_weapon then
                weight += call_offset_r1(0x477B88, item) * items;  /* Engine get weight for weapon */
            else if armor_engine_weight(item_pid) then
                weight += (proto_data(item_pid, it_weight) / 2) * items;
            else weight += proto_data(item_pid, it_weight) * items;
            prev_counter := item_counter;
         end

     end
     else begin
        item_counter++;
        prev_counter++;
     end
   end

   return weight;
end

procedure filter_remove_items(variable source_objptr, variable dest_objptr, variable item, variable item_pid) begin

   variable items := rm_mult_objs_from_inven(source_objptr, item, obj_is_carrying_obj_pid(source_objptr, item_pid)); // obj_is_carrying_obj(source_objptr, item)

   // обход бага в функции add_mult_objs_to_inven для монет если количество превышает 99999
   if (item_pid == PID_BOTTLE_CAPS) then
      item_caps_adjust(dest_objptr, items);
   else
      add_mult_objs_to_inven(dest_objptr, item, items);

end

procedure check_tile_object begin
   variable objptr, objtype;

   debug_msg("Filter: Check tile object.");

   if skill_object > 0 then begin
      debug_msg("  >>>  used skill object.");
      object_array := create_array_list(1);
      object_array[0] := skill_object;
      skill_object := 0; // обнуляем
   end else
      object_array := tile_get_objs(tile_num_in_direction(dude_tile, dude_cur_rot, 1), dude_elevation);

   //находим в массиве первый найденный контейнер
   foreach (objptr in object_array) begin
      if objptr != 0 then
         objtype := obj_item_subtype(objptr);
      if objtype == item_type_container then begin    // это контейнер
         contr_ptr := objptr;                         // указатель на контейнер
         break;
      end
   end

   if objtype != item_type_container then begin
      objptr := Check_Party_Obj;       //проверка на обмен с партийцем
      if objptr != (-1) then
         contr_ptr := objptr;          // указатель на партийца
      else contr_ptr := 0;
   end
   else if not(sfall_crafty) then begin // для старых оригинальных версий без LOOT
      if Trunk_Ptr != contr_ptr then
         contr_ptr := 0;
   end

   if contr_ptr > 0 then begin
      contr_use := true;               // использует контейнер или партиец
      loot_filter := true;             // фильтровать по приципу сортировки для контейнеров
   end

   clear_array(object_array);          //обнулить массив
end

procedure Check_Party_Obj begin

   variable party_array := party_member_list_critters; // тут ptr
   variable n, len := len_array(party_array);

   debug_msg("Filter: Lookup in party.");
   for (n := 1; n < len; n++) begin
      if is_in_array(party_array[n], object_array) then
         return party_array[n]; //возвращаем указатель на партийца
   end

   debug_msg("Filter: Object is not party member.");
   return -1;  //нет партийцев в массиве объектов
end

procedure Move_Dude_Inv begin

variable crtr, item_ptr;

   crtr := create_object(PID_MELEE_THUG_MALE, 0, 2);

   while inven_ptr(dude_obj, 0) > 0 do begin
      item_ptr := inven_ptr(dude_obj, 0);
      call filter_remove_items(dude_obj, crtr, item_ptr, obj_pid(item_ptr));
   end

   return crtr;

end

procedure check_bags_items(variable who_ptr) begin

variable t1_array, t2_array, item, i, n := 0;

   if (no_check_bags) then return;

   //check item containers
   t1_array := temp_array_list(1);
   while inven_ptr(who_ptr, i) > 0 and i < 1000 do begin
      item:=inven_ptr(who_ptr, i);
      if obj_item_subtype(item) == item_type_container then begin
         t1_array[n] := item; // в t1 находятся указатели на контейнеры
         n++;
         resize_array(t1_array, n + 1);
      end
      i++;
   end
   //remove item containers
   if n > 0 then begin
      debug_msg("Filter: check bags...");
      t2_array:=temp_array_list(n);
      for (i := 0; i < n; i++) begin
         t2_array[i] := obj_is_carrying_obj_pid(who_ptr, obj_pid(t1_array[i])); // в t2 находятся количество для каждого контейнера
         rm_obj_from_inven(who_ptr, t1_array[i]);
      end
      debug_msg("   remove items container count: "+i);
      i := 0;
      if who_ptr == dude_obj then begin
         if not(array_exists(container_array)) then begin
             //create copy array
             n := len_array(t1_array);
             container_array := create_array_list(n);
             foreach i: item in t1_array begin
               container_array[i] := item; // сохраняем указатели из t1
             end
             container_count_array:=create_array_list(n);
             foreach i: item in t2_array begin
               container_count_array[i] := item; // сохраняем количество из t2
             end
         end
         else begin
            //add to array
            n := len_array(container_array) - 1;
            item := len_array(t1_array) - 1;
            resize_array(container_array, (n + item) + 1);
            resize_array(container_count_array, (n + item) + 1);
            //display_msg("resize len container_array: "+(len_array(container_array)-1));
            for (i := 0; i < item; i++) begin
               container_array[n + i] := t1_array[i];
               container_count_array[n + i] := t2_array[i];
            end
            debug_msg("  new containers add to dude array, count: "+i);
         end
      end
      else begin
         if not(array_exists(trd_container_array)) then begin
            //create copy array
            trd_container_array := create_array_list(len_array(t1_array));
            foreach i: item in t1_array begin
              trd_container_array[i] := item;
            end
            trd_container_count_array := create_array_list(len_array(t2_array));
            foreach i: item in t2_array begin
              trd_container_count_array[i] := item;
            end
         end
         else begin
            //add to array
            n := len_array(trd_container_array) - 1;
            item := len_array(t1_array) - 1;
            resize_array(trd_container_array, (n + item) + 1);
            resize_array(trd_container_count_array, (n + item) + 1);
            for (i := 0; i < item; i++) begin
               trd_container_array[n + i] := t1_array[i];
               trd_container_count_array[n + i] := t2_array[i];
            end
            debug_msg("   new containers add to trader/loot array, count: "+i);
         end
      end
   end //else display_msg("   No items container.");

end

procedure restore_bags_items(variable who_ptr) begin

   variable i, n, w;

   if who_ptr == dude_obj then begin
      if array_exists(container_array) then begin
        n := len_array(container_array) - 1;
        debug_msg("Filter: Need restore bags... : " + n);
        for (i := 0; i < n; i++) begin                // узнать вес контейнера и его содержимого
           if not(dude_in_barter or loot_filter) then w += (call_offset_r1(0x477B88, container_array[i]) * container_count_array[i]);
           add_mult_objs_to_inven(dude_obj, container_array[i], container_count_array[i]);
        end
        free_array(container_array);
        free_array(container_count_array);
        debug_msg("Filter: Restore dude item bags. Count: "+i);
      end
      return w;
   end else begin
      if array_exists(trd_container_array) then begin
        n := len_array(trd_container_array) - 1;
        for (i := 0; i < n; i++) begin
           add_mult_objs_to_inven(who_ptr, trd_container_array[i], trd_container_count_array[i]);
        end
        free_array(trd_container_array);
        free_array(trd_container_count_array);
        debug_msg("Filter: Restore trader/loot item bags. Count: "+i);
      end
   end

end

procedure hMoveItem begin
/*
   critter arg1 - the critter the object is being removed from
   item    arg2 - the item that is being removed
   int     arg3 - a flag, or possibly the number of items to remove
   int     arg4 - The reason the object is being removed. (Actually, the site from which _item_remove_mult was called)
*/
   variable obj, item, count, weight;

   if enable_filter and enable_weight and loot_filter and filter_done and not(loot_weight)then begin
      loot_weight:=true;
   end

   if not(inven_weight) or not(enable_filter) then
      return;

   obj   := get_sfall_arg;
   item  := get_sfall_arg;
   count := get_sfall_arg;

   // flag
   if get_sfall_arg == RMOBJ_TRADE then begin
      if (obj != dude_obj and obj != pc_bTable) then
         return;

      weight := call_offset_r1(0x477B88, item) * count;
      if (obj == dude_obj) then
         weight := 0 - weight;

      call barter_weight_win(weight);
   end

end

procedure hBarter begin
/*
   critter arg1 - the critter doing the bartering (either dude_obj or inven_dude)
   critter arg2 - the critter being bartered with
   int     arg3 - the default value of the goods
   critter arg4 - the barter critter (has all of the goods being traded in its inventory)
   int     arg5 - the amount of actual caps in the barter stack (as opposed to goods)
   int     arg6 - the value of all goods being traded before skill modifications
   +
   critter arg7 - указатель на "стол" с предложенными игроком товарами
   int     arg8 - общая стоимость предложенных игроком товаров (отдельно можно узнать количество денег с помощью item_caps_total(arg7))
   int     arg9 - 1 если была нажата кнопка "предложения обмена" не сопартийцу, иначе 0.
*/
   variable barter_args, caps, diff;

   if not(enable_filter) then return;

   barter_args := get_sfall_args;

   if not(dude_enter_barter) then begin
      dude_in_barter := true;
      dude_enter_barter := true;
      trader_ptr := barter_args[1];
      pc_bTable := barter_args[6];
   end

   if smart_barter and barter_args[8] then begin
      diff := barter_args[2] - barter_args[7]; // разница цены в предложенных товарах, отрицательное - задолженость для торговца
      if (diff < 0) then begin
         caps := item_caps_total(trader_ptr);
         if (caps > 0) then begin
            if (0 - diff) > caps then diff := 0 - caps;
         end else diff := 0;
      end
      else if (item_caps_total(dude_obj) < diff) then diff := 0;

      if (diff != 0) then begin
         item_caps_adjust(dude_obj, -diff);
         item_caps_adjust(trader_ptr, diff);
         set_sfall_return(barter_args[7]);
      end
   end

   call trader_cost_win when (inven_caps and enable_caps);

end

procedure hKeyPress begin

variable type  := get_sfall_arg,
         key   := get_sfall_arg;

   if key == DIK_F2 and get_game_mode == 0 and type == 0 then begin
      if enable_filter then begin
         enable_filter := false;
         //"Inventory Filter is disabled."
         display_msg(get_ini_string(iniConfigFile + "MsgOff"));
      end else begin
         enable_filter := true;
         //"Inventory Filter is enabled."
         display_msg(get_ini_string(iniConfigFile + "MsgOn") + SCRIPT_VERSION);
      end
      set_sfall_global("INV_FLTR", not(enable_filter));
   end

end

procedure hMouseClick begin

variable type, button;

   if not(enable_filter) then return;

   if ((get_game_mode BWAND (INVENTORY BWOR INTFACEUSE BWOR BARTER)) or loot_filter or dude_enter_barter) then begin

      type   := get_sfall_arg;   // event type: 1 - pressed, 0 - released
      button := get_sfall_arg;   // button number (0 - left, 1 - right, up to 7)

      if button == 0 then begin
         if type == 1 then begin
             x_mouse := get_mouse_x;
             y_mouse := get_mouse_y;
         end

         #if COMBINE_VERSION
            if not(sfall_crafty) then begin
               if type == 0 and dude_enter_barter and button_exit_barter and button_exit_barter_check then
                  dude_in_barter := false;                            //(get_game_mode BWAND INTFACELOOT)
               if type == 0 and loot_filter and not(dude_enter_barter) and button_exit_loot and button_exit_loot_check  then
                  loot_filter := false;
            end
         #endif

         if inven_filter_button_all and not(btn_all) and not(loot_filter) then               // button all no filter
            call inven_filter_button_pressed("all", -1, 0);
         else if inven_filter_button_armor and not(btn_armor) then                           // button armor
            call inven_filter_button_pressed("armor", item_type_armor, 0);
         else if inven_filter_button_weapon and not(btn_weapon) then                         // button weapon
            call inven_filter_button_pressed("weapon", item_type_weapon, 0);
         else if inven_filter_button_ammo and not(btn_ammo) then                             // button ammo
            call inven_filter_button_pressed("ammo", item_type_ammo, 0);
         else if inven_filter_button_drug and not(btn_drug) then                             // button drug
            call inven_filter_button_pressed("drug", item_type_drug, 0);
         else if inven_filter_button_misc and not(btn_misc) then begin                       // button mis
            call inven_filter_button_pressed("misc", item_type_misc_item, 0);
            sec_click := true;
         end // for trader/loot
         else if inven_filter_trd_button_all and not(btn_trd_all) and not(loot_filter) then  // button all no filter
            call inven_filter_trd_button_pressed("all", -1);
         else if inven_filter_trd_button_armor and not(btn_trd_armor) then                   // button armor
            call inven_filter_trd_button_pressed("armor", item_type_armor);
         else if inven_filter_trd_button_weapon and not(btn_trd_weapon) then                 // button weapon
            call inven_filter_trd_button_pressed("weapon", item_type_weapon);
         else if inven_filter_trd_button_ammo and not(btn_trd_ammo) then                     // button ammo
            call inven_filter_trd_button_pressed("ammo", item_type_ammo);
         else if inven_filter_trd_button_drug and not(btn_trd_drug) then                     // button drug
            call inven_filter_trd_button_pressed("drug", item_type_drug);
         else if inven_filter_trd_button_misc and not(btn_trd_misc) then                     // button mis
            call inven_filter_trd_button_pressed("misc", item_type_misc_item);

      end // клик средней кнопкой мышки по кнопкам патроны или оружие
      else if button == 2 then begin
          if (btn_ammo or btn_weapon) then begin
             if inven_filter_button_ammo and not(btn_ammo) then                     // button ammo
               call inven_filter_button_pressed("ammo", item_type_ammo, 1);
             else if inven_filter_button_weapon and not(btn_weapon) then            // button weapon
               call inven_filter_button_pressed("weapon", item_type_weapon, 1);
          end
          if inven_filter_button_misc and (not(btn_misc) or sec_click) then begin   // button misc
            call inven_filter_button_pressed("misc", item_type_misc_group, 0);
            sec_click := false;
          end
      end

      if pressed_once and type == 0 then pressed_once := false;
   end

end

procedure inven_filter_button_pressed(variable p_btn, variable filter_item_type, variable spec) begin
variable _curr_stack, text;

   if not(pressed_once) then begin
      pressed_once := true;
      filter_done := false;

      //call_offset_v2(0x476394, 2500, 0); //функция закрыть открытую сумку
      _curr_stack := read_int(0x59E96C);  // проверить открыты ли сумки
      if _curr_stack > 0 then begin
        play_sfx("IISXXXX1");
        text := get_ini_string(iniConfigFile + "MsgWarning");
        if not(dude_in_barter) then create_message_window(text); else display_msg(text);
      end
      else begin
        play_sfx("IB2P1XX1");
        call inven_filter_button_toggle(p_btn, spec);  //button down so highlight!
        call filter_inventory(filter_item_type, spec);
      end

   end

end

procedure inven_filter_button_toggle(variable p_btn, variable spec) begin

   if loot_filter then btn_toggle_off:=true;

   selectWin("inven_filter");
   if not((spec) and (btn_ammo or btn_weapon)) then begin
      call create_btn_sub;

      if special then begin
         call DeletePressButton;
         call Create_btn_ammo("off", 0);
         special := false;
      end
   end
   else special := true;

   call SelectCreateButton(p_btn, false);
   showWin;

//   debug_msg("btn_all: "+ btn_all);
//   debug_msg("btn_armor: "+ btn_armor);
//   debug_msg("btn_weapon:" + btn_weapon);
//   debug_msg("btn_ammo:" + btn_ammo);
//   debug_msg("btn_drug:" + btn_drug);
//   debug_msg("btn_misc:" + btn_misc);
//   debug_msg("-----end------");

end

procedure inven_filter_trd_button_pressed(variable p_btn, variable filter_item_type) begin
variable _target_curr_stack, text;

   if not(pressed_once) then begin
       pressed_once := true;
       filter_done := false;

       _target_curr_stack := read_int(0x59E948);  // проверить открыты ли сумки у цели
       if _target_curr_stack > 0 then begin
           play_sfx("IISXXXX1");
           text := get_ini_string(iniConfigFile + "MsgWarning");
           if loot_filter then create_message_window(text); else display_msg(text);
       end
       else begin
         play_sfx("IB2P1XX1");
         call inven_filter_trd_button_toggle(p_btn);  //button down so highlight!
         call filter_inventory_trader(filter_item_type);
       end

   end

end

procedure inven_filter_trd_button_toggle(variable p_btn) begin

   if loot_filter then btn_trd_toggle_off := true;

   selectWin("inven_filter_trd");

   call create_btn_trd_sub;
   call SelectCreateButton(p_btn, true);

   showWin;

end

procedure Button_Toggle_Off begin

   if get_mouse_buttons == 0 then begin
      if btn_toggle_off then begin
         btn_toggle_off := false;
         selectWin("inven_filter");
         call create_btn_sub;
         showWin;
      end
      else if btn_trd_toggle_off then begin
         btn_trd_toggle_off := false;
         selectWin("inven_filter_trd");
         call create_btn_trd_sub;
         showWin;
      end
   end

end

procedure SelectCreateButton(variable p_btn, variable flag) begin

   //удалить кнопку которая была нажата
   call subDeleteButton(p_btn, "off", flag);

   // создать новую кнопку которая была нажата.
   switch p_btn begin
      case "all"    : call Create_btn_all("on", flag);
      case "armor"  : call Create_btn_armor("on", flag);
      case "weapon" : call Create_btn_weapon("on", flag);
      case "ammo"   : call Create_btn_ammo("on", flag);
      case "drug"   : call Create_btn_drug("on", flag);
      case "misc"   : call Create_btn_misc("on", flag);
   end

end

procedure create_btn_sub begin

   // удалить предыдущую нажатую кнопку
   call DeletePressButton;

   //создать на месте удаленноей кнопки новую кнопку (закрыть дыру)
   if btn_all then         call Create_btn_all("off", 0);
   else if btn_armor then  call Create_btn_armor("off", 0);
   else if btn_weapon then call Create_btn_weapon("off", 0);
   else if btn_ammo then   call Create_btn_ammo("off", 0);
   else if btn_drug then   call Create_btn_drug("off", 0);
   else if btn_misc then   call Create_btn_misc("off", 0);

end

procedure create_btn_trd_sub begin

   // удалить предыдущую нажатую кнопку
   call DeletePressButtonTrd;

   //создать на месте удаленноей кнопки новую кнопку (закрыть дыру)
   if btn_trd_all then         call Create_btn_all("off", 1);
   else if btn_trd_armor then  call Create_btn_armor("off", 1);
   else if btn_trd_weapon then call Create_btn_weapon("off", 1);
   else if btn_trd_ammo then   call Create_btn_ammo("off", 1);
   else if btn_trd_drug then   call Create_btn_drug("off", 1);
   else if btn_trd_misc then   call Create_btn_misc("off", 1);

end

procedure Create_btn_all(variable flag, variable trd) begin

   call subCreateButton("all", flag, trd, 0);

   if not(trd) then begin
       if flag == "on" then btn_all := true; else btn_all := false;
   end else if flag == "on" then btn_trd_all := true; else btn_trd_all := false;

end

procedure Create_btn_armor(variable flag, variable trd) begin

   call subCreateButton("armor", flag, trd, 1);

   if not(trd) then begin
      if flag == "on" then btn_armor := true; else btn_armor := false;
   end else if flag == "on" then btn_trd_armor := true; else btn_trd_armor :=false;

end

procedure Create_btn_weapon(variable flag, variable trd) begin

   call subCreateButton("weapon", flag, trd, 2);

   if not(trd) then begin
       if flag == "on" then btn_weapon := true; else btn_weapon := false;
   end else if flag == "on" then btn_trd_weapon := true; else btn_trd_weapon := false;

end

procedure Create_btn_ammo(variable flag, variable trd) begin

   call subCreateButton("ammo", flag, trd, 3);

   if not(trd) then begin
       if flag == "on" then btn_ammo := true; else btn_ammo := false;
   end else if flag == "on" then btn_trd_ammo := true; else btn_trd_ammo := false;

end

procedure Create_btn_drug(variable flag, variable trd) begin

   call subCreateButton("drug", flag, trd, 4);

   if not(trd) then begin
       if flag == "on" then btn_drug := true; else btn_drug := false;
   end else if flag == "on" then btn_trd_drug := true; else btn_trd_drug := false;

end

procedure Create_btn_misc(variable flag, variable trd) begin

   call subCreateButton("misc", flag, trd, 5);

   if not(trd) then begin
       if flag == "on" then btn_misc := true; else btn_misc := false;
   end else if flag == "on" then btn_trd_misc := true; else btn_trd_misc := false;

end

procedure subCreateButton(variable btn, variable flag, variable trd, variable vshift) begin

   variable btn_name, btn_on, btn_off, btn_hover;

   btn_name  := "filter_" + btn + "_" + flag + trd;
   btn_on    := "PCX\\inv_filter\\btn_" + btn + "_on.pcx";
   btn_off   := "PCX\\inv_filter\\btn_" + btn + "_" + flag + ".pcx";
   btn_hover := "PCX\\inv_filter\\btn_" + btn + "_hover_" + flag + ".pcx";

   addButton(btn_name, x_loc, 1 + y_loc + (vertic_size * vshift), horiz_size, 20);
   addButtonGfx(btn_name, btn_on, btn_off, btn_hover);
   addButtonProc(btn_name, None, None, None, None);  // inven buttons don't work

end

procedure DeletePressButton begin

variable btn;

   if btn_all then         btn := "all";
   else if btn_armor then  btn := "armor";
   else if btn_weapon then btn := "weapon";
   else if btn_ammo then   btn := "ammo";
   else if btn_drug then   btn := "drug";
   else if btn_misc then   btn := "misc";
   else return;

   call subDeleteButton(btn, "on", false);

end

procedure DeletePressButtonTrd begin

variable btn;

   if btn_trd_all then         btn:= "all";
   else if btn_trd_armor then  btn:= "armor";
   else if btn_trd_weapon then btn:= "weapon";
   else if btn_trd_ammo then   btn:= "ammo";
   else if btn_trd_drug then   btn:= "drug";
   else if btn_trd_misc then   btn:= "misc";
   else return;

   call subDeleteButton(btn, "on", true);

end

procedure subDeleteButton(variable btn, variable type, variable flag) begin

   deleteButton("filter_" + btn + "_" + type + flag);

end

procedure weight_win(variable weight, variable type) begin

   //создание окна для отображения веса предметов
   if not(inven_weight) then begin
      createWin("inven_weight", menu_x, menu_y + 150, 63, 20);
      inven_weight := true;
   end
   else if (type == -1) then begin
      DeleteWin("inven_weight");
      inven_weight := false;
   end

   if inven_weight then begin
      selectWin("inven_weight");
      display("PCX/inv_filter/weight.pcx");
      SetFont(1);
      if (weight > dude_weight) then
          SetTextColor(1.0, 0.1, 0.0);
      else
          SetTextColor(0.0, 1.0, 0.0);
      Format(mstr_inventry(30) + ": " + weight, 5, 5, 63, 10, 0);
      showWin;
   end

end

procedure weight_loot_win(variable weight, variable obj) begin

   //создание окна для отображения веса предметов
   if not(inven_loot_weight) then begin
      createWin("inven_loot_weight", t_menu_x, menu_y + 150, 63, 20);
      inven_loot_weight := true;
   end

   selectWin("inven_loot_weight");
   display("PCX/inv_filter/weight.pcx");
   SetFont(1);
   if (weight > get_critter_stat(obj, STAT_carry_amt)) then
      SetTextColor(1.0, 0.1, 0.0);
   else
      SetTextColor(0.0, 1.0, 0.0);
   Format(mstr_inventry(30) + ": " + weight, 5, 5, 63, 10, 0);
   showWin;

end

procedure barter_weight_win(variable weight) begin

   variable carry := who_carry_amount(dude_obj) + weight;
   if critter then carry += who_carry_amount(critter);

   //создание окна для отображения веса при торге
   if not(inven_weight) then begin
      inven_weight := true;
      createWin("inven_weight", menu_x, menu_y - 20, 63, 20);
   end

   selectWin("inven_weight");
   display("PCX/inv_filter/weight.pcx");
   if (carry > dude_weight) then
      SetTextColor(1.0, 0.1, 0.0);
   else
      SetTextColor(0.0, 1.0, 0.0);
   Format(mstr_inventry(30) + ": " + carry, 5, 6, 63, 10, justifyleft);
   showWin;

end

procedure trader_cost_win begin

   //создание окна для отображения налички у торговца
   if not(inven_caps) then begin
      inven_caps := true;
      createWin("inven_caps", t_menu_x, menu_y - 20, 63, 20);
   end

   selectWin("inven_caps");
   display("PCX/inv_filter/weight.pcx");
   SetTextColor(0.0, 1.0, 0.0);
   Format("$" + item_caps_total(trader_ptr), 0, 6, 63, 10, justifycenter);
   showWin;

end

procedure None begin
end

#if COMBINE_VERSION
procedure Dude_Loot_Object begin

   if not(used) and (art_anim(obj_art_fid(dude_obj)) == ANIM_magic_hands_middle) then begin
      debug_msg("Filter: Dude loot object - pass ready.");
      CNTR_USE := dude_tile;
      used := true;
      usedSkill := false;
   end
   else if used then begin
      if not(anim_busy(dude_obj)) and CNTR_USE == dude_tile and not(usedSkill) then begin
         debug_msg("Filter: Dude loot object - pass done.");
         call check_tile_object;
         CNTR_USE := -1;
         used := false;
      end
      else if CNTR_USE != dude_tile then
               used := false;

      if usedSkill then
         used := false;
   end

end
#endif

procedure hUseSkills begin
   variable temp;

   if not(enable_filter) then
      return;

   temp := get_sfall_arg;
   temp := get_sfall_arg;  // this object

   if get_sfall_arg == SKILL_STEAL then
      skill_object := temp;
   else
      usedSkill := true;   // флаг использованния умения отличного от кражи

end

procedure hack_engine_weight(variable hack) begin

   if (hack) then begin
      _hack_weight := true;
      write_byte(0x477EE1, 0xEB);
   end
   else begin
      _hack_weight := false;
      write_byte(0x477EE1, 0x75);
   end

end
